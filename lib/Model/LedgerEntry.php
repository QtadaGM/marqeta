<?php
/**
 * LedgerEntry
 *
 * PHP version 7.3
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Core API
 *
 * Marqeta's Core API endpoints, conveniently annotated to enable code generation (including SDKs), test cases, and documentation. Currently in beta.
 *
 * The version of the OpenAPI document: 3.0.19
 * Contact: support@marqeta.com
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 5.4.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Model;

use \ArrayAccess;
use \OpenAPI\Client\ObjectSerializer;

/**
 * LedgerEntry Class Doc Comment
 *
 * @category Class
 * @description Contains information about a ledger entry.
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 * @implements \ArrayAccess<TKey, TValue>
 * @template TKey int|null
 * @template TValue mixed|null
 */
class LedgerEntry implements ModelInterface, ArrayAccess, \JsonSerializable
{
    public const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = 'LedgerEntry';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'account_token' => 'string',
        'amount' => 'float',
        'card_token' => 'string',
        'created_time' => '\DateTime',
        'currency_code' => '\OpenAPI\Client\Model\CurrencyCode',
        'detail_object' => 'object',
        'detail_token' => 'string',
        'dispute_token' => 'string',
        'group' => 'string',
        'id' => 'string',
        'impact_time' => '\DateTime',
        'memo' => 'string',
        'original_currency' => '\OpenAPI\Client\Model\OriginalCurrency',
        'related_token' => 'string',
        'request_time' => '\DateTime',
        'root_token' => 'string',
        'status' => 'string',
        'token' => 'string',
        'type' => 'string'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      * @phpstan-var array<string, string|null>
      * @psalm-var array<string, string|null>
      */
    protected static $openAPIFormats = [
        'account_token' => 'string',
        'amount' => null,
        'card_token' => 'string',
        'created_time' => 'date-time',
        'currency_code' => null,
        'detail_object' => null,
        'detail_token' => null,
        'dispute_token' => null,
        'group' => null,
        'id' => null,
        'impact_time' => 'date-time',
        'memo' => null,
        'original_currency' => null,
        'related_token' => null,
        'request_time' => 'date-time',
        'root_token' => null,
        'status' => null,
        'token' => null,
        'type' => null
    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'account_token' => 'account_token',
        'amount' => 'amount',
        'card_token' => 'card_token',
        'created_time' => 'created_time',
        'currency_code' => 'currency_code',
        'detail_object' => 'detail_object',
        'detail_token' => 'detail_token',
        'dispute_token' => 'dispute_token',
        'group' => 'group',
        'id' => 'id',
        'impact_time' => 'impact_time',
        'memo' => 'memo',
        'original_currency' => 'original_currency',
        'related_token' => 'related_token',
        'request_time' => 'request_time',
        'root_token' => 'root_token',
        'status' => 'status',
        'token' => 'token',
        'type' => 'type'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'account_token' => 'setAccountToken',
        'amount' => 'setAmount',
        'card_token' => 'setCardToken',
        'created_time' => 'setCreatedTime',
        'currency_code' => 'setCurrencyCode',
        'detail_object' => 'setDetailObject',
        'detail_token' => 'setDetailToken',
        'dispute_token' => 'setDisputeToken',
        'group' => 'setGroup',
        'id' => 'setId',
        'impact_time' => 'setImpactTime',
        'memo' => 'setMemo',
        'original_currency' => 'setOriginalCurrency',
        'related_token' => 'setRelatedToken',
        'request_time' => 'setRequestTime',
        'root_token' => 'setRootToken',
        'status' => 'setStatus',
        'token' => 'setToken',
        'type' => 'setType'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'account_token' => 'getAccountToken',
        'amount' => 'getAmount',
        'card_token' => 'getCardToken',
        'created_time' => 'getCreatedTime',
        'currency_code' => 'getCurrencyCode',
        'detail_object' => 'getDetailObject',
        'detail_token' => 'getDetailToken',
        'dispute_token' => 'getDisputeToken',
        'group' => 'getGroup',
        'id' => 'getId',
        'impact_time' => 'getImpactTime',
        'memo' => 'getMemo',
        'original_currency' => 'getOriginalCurrency',
        'related_token' => 'getRelatedToken',
        'request_time' => 'getRequestTime',
        'root_token' => 'getRootToken',
        'status' => 'getStatus',
        'token' => 'getToken',
        'type' => 'getType'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }

    const GROUP_PURCHASE = 'PURCHASE';
    const GROUP_INTERNAL = 'INTERNAL';
    const GROUP_FEE = 'FEE';
    const GROUP_REWARD = 'REWARD';
    const GROUP_INTEREST = 'INTEREST';
    const GROUP_PAYMENT = 'PAYMENT';
    const GROUP_ADJUSTMENT = 'ADJUSTMENT';
    const GROUP_BALANCE_TRANSFER = 'BALANCE_TRANSFER';
    const GROUP_CASH_ADVANCE = 'CASH_ADVANCE';
    const GROUP_BALANCE_REFUND = 'BALANCE_REFUND';
    const GROUP_ORIGINAL_CREDIT = 'ORIGINAL_CREDIT';
    const STATUS_PENDING = 'PENDING';
    const STATUS_POSTED = 'POSTED';
    const STATUS_DECLINED = 'DECLINED';
    const STATUS_ERROR = 'ERROR';
    const STATUS_CLEARED = 'CLEARED';

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getGroupAllowableValues()
    {
        return [
            self::GROUP_PURCHASE,
            self::GROUP_INTERNAL,
            self::GROUP_FEE,
            self::GROUP_REWARD,
            self::GROUP_INTEREST,
            self::GROUP_PAYMENT,
            self::GROUP_ADJUSTMENT,
            self::GROUP_BALANCE_TRANSFER,
            self::GROUP_CASH_ADVANCE,
            self::GROUP_BALANCE_REFUND,
            self::GROUP_ORIGINAL_CREDIT,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getStatusAllowableValues()
    {
        return [
            self::STATUS_PENDING,
            self::STATUS_POSTED,
            self::STATUS_DECLINED,
            self::STATUS_ERROR,
            self::STATUS_CLEARED,
        ];
    }

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['account_token'] = $data['account_token'] ?? null;
        $this->container['amount'] = $data['amount'] ?? null;
        $this->container['card_token'] = $data['card_token'] ?? null;
        $this->container['created_time'] = $data['created_time'] ?? null;
        $this->container['currency_code'] = $data['currency_code'] ?? null;
        $this->container['detail_object'] = $data['detail_object'] ?? null;
        $this->container['detail_token'] = $data['detail_token'] ?? null;
        $this->container['dispute_token'] = $data['dispute_token'] ?? null;
        $this->container['group'] = $data['group'] ?? null;
        $this->container['id'] = $data['id'] ?? null;
        $this->container['impact_time'] = $data['impact_time'] ?? null;
        $this->container['memo'] = $data['memo'] ?? null;
        $this->container['original_currency'] = $data['original_currency'] ?? null;
        $this->container['related_token'] = $data['related_token'] ?? null;
        $this->container['request_time'] = $data['request_time'] ?? null;
        $this->container['root_token'] = $data['root_token'] ?? null;
        $this->container['status'] = $data['status'] ?? null;
        $this->container['token'] = $data['token'] ?? null;
        $this->container['type'] = $data['type'] ?? null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        if ($this->container['account_token'] === null) {
            $invalidProperties[] = "'account_token' can't be null";
        }
        if ($this->container['amount'] === null) {
            $invalidProperties[] = "'amount' can't be null";
        }
        if ($this->container['card_token'] === null) {
            $invalidProperties[] = "'card_token' can't be null";
        }
        if ((mb_strlen($this->container['card_token']) > 36)) {
            $invalidProperties[] = "invalid value for 'card_token', the character length must be smaller than or equal to 36.";
        }

        if ((mb_strlen($this->container['card_token']) < 8)) {
            $invalidProperties[] = "invalid value for 'card_token', the character length must be bigger than or equal to 8.";
        }

        if ($this->container['created_time'] === null) {
            $invalidProperties[] = "'created_time' can't be null";
        }
        if ($this->container['currency_code'] === null) {
            $invalidProperties[] = "'currency_code' can't be null";
        }
        if ($this->container['detail_token'] === null) {
            $invalidProperties[] = "'detail_token' can't be null";
        }
        if ($this->container['group'] === null) {
            $invalidProperties[] = "'group' can't be null";
        }
        $allowedValues = $this->getGroupAllowableValues();
        if (!is_null($this->container['group']) && !in_array($this->container['group'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'group', must be one of '%s'",
                $this->container['group'],
                implode("', '", $allowedValues)
            );
        }

        if ($this->container['id'] === null) {
            $invalidProperties[] = "'id' can't be null";
        }
        if ((mb_strlen($this->container['id']) > 8)) {
            $invalidProperties[] = "invalid value for 'id', the character length must be smaller than or equal to 8.";
        }

        if ((mb_strlen($this->container['id']) < 8)) {
            $invalidProperties[] = "invalid value for 'id', the character length must be bigger than or equal to 8.";
        }

        if ($this->container['impact_time'] === null) {
            $invalidProperties[] = "'impact_time' can't be null";
        }
        if ($this->container['memo'] === null) {
            $invalidProperties[] = "'memo' can't be null";
        }
        if ($this->container['request_time'] === null) {
            $invalidProperties[] = "'request_time' can't be null";
        }
        if ($this->container['status'] === null) {
            $invalidProperties[] = "'status' can't be null";
        }
        $allowedValues = $this->getStatusAllowableValues();
        if (!is_null($this->container['status']) && !in_array($this->container['status'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'status', must be one of '%s'",
                $this->container['status'],
                implode("', '", $allowedValues)
            );
        }

        if ($this->container['token'] === null) {
            $invalidProperties[] = "'token' can't be null";
        }
        if ($this->container['type'] === null) {
            $invalidProperties[] = "'type' can't be null";
        }
        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets account_token
     *
     * @return string
     */
    public function getAccountToken()
    {
        return $this->container['account_token'];
    }

    /**
     * Sets account_token
     *
     * @param string $account_token Unique identifier of the credit account associated with the credit card used to make the ledger entry.
     *
     * @return self
     */
    public function setAccountToken($account_token)
    {
        $this->container['account_token'] = $account_token;

        return $this;
    }

    /**
     * Gets amount
     *
     * @return float
     */
    public function getAmount()
    {
        return $this->container['amount'];
    }

    /**
     * Sets amount
     *
     * @param float $amount Amount of the ledger entry.
     *
     * @return self
     */
    public function setAmount($amount)
    {
        $this->container['amount'] = $amount;

        return $this;
    }

    /**
     * Gets card_token
     *
     * @return string
     */
    public function getCardToken()
    {
        return $this->container['card_token'];
    }

    /**
     * Sets card_token
     *
     * @param string $card_token Unique identifier of the credit card used to make the ledger entry.
     *
     * @return self
     */
    public function setCardToken($card_token)
    {
        if ((mb_strlen($card_token) > 36)) {
            throw new \InvalidArgumentException('invalid length for $card_token when calling LedgerEntry., must be smaller than or equal to 36.');
        }
        if ((mb_strlen($card_token) < 8)) {
            throw new \InvalidArgumentException('invalid length for $card_token when calling LedgerEntry., must be bigger than or equal to 8.');
        }

        $this->container['card_token'] = $card_token;

        return $this;
    }

    /**
     * Gets created_time
     *
     * @return \DateTime
     */
    public function getCreatedTime()
    {
        return $this->container['created_time'];
    }

    /**
     * Sets created_time
     *
     * @param \DateTime $created_time Date and time when the ledger entry was created on Marqeta's credit platform, in UTC.
     *
     * @return self
     */
    public function setCreatedTime($created_time)
    {
        $this->container['created_time'] = $created_time;

        return $this;
    }

    /**
     * Gets currency_code
     *
     * @return \OpenAPI\Client\Model\CurrencyCode
     */
    public function getCurrencyCode()
    {
        return $this->container['currency_code'];
    }

    /**
     * Sets currency_code
     *
     * @param \OpenAPI\Client\Model\CurrencyCode $currency_code currency_code
     *
     * @return self
     */
    public function setCurrencyCode($currency_code)
    {
        $this->container['currency_code'] = $currency_code;

        return $this;
    }

    /**
     * Gets detail_object
     *
     * @return object|null
     */
    public function getDetailObject()
    {
        return $this->container['detail_object'];
    }

    /**
     * Sets detail_object
     *
     * @param object|null $detail_object Contains the ledger entry's full details. The fields returned in this object vary based on the ledger entry group.  The following lists each ledger entry group and the specific fields returned for each group.  * Purchases and refunds: see the <</core-api/transactions#getTransactions, transactions>> response fields.  * Disputes: see the <</core-api/credit-disputes#retrieveDispute, account disputes response fields.>>  * Original credit transaction (OCT): see the <</core-api/push-to-card-payments#_create_push_to_card_disbursement, Push-to-Card disbursement>> fields.  * Rewards: see the <</core-api/credit-account-rewards#createReward, account reward>> response fields.  * Payments: see the <</core-api/credit-account-payments#retrievePayment, account payment>> response fields.  * Balance refunds: see the <</core-api/credit-balance-refunds#createBalanceRefund, balance refund>> response fields.  * Adjustments: see the <</core-api/credit-account-adjustments#retrieveAdjustment, account adjustment>> response fields.  * Interest and fees: see fields below.
     *
     * @return self
     */
    public function setDetailObject($detail_object)
    {
        $this->container['detail_object'] = $detail_object;

        return $this;
    }

    /**
     * Gets detail_token
     *
     * @return string
     */
    public function getDetailToken()
    {
        return $this->container['detail_token'];
    }

    /**
     * Sets detail_token
     *
     * @param string $detail_token Unique identifier of the ledger entry's full details.
     *
     * @return self
     */
    public function setDetailToken($detail_token)
    {
        $this->container['detail_token'] = $detail_token;

        return $this;
    }

    /**
     * Gets dispute_token
     *
     * @return string|null
     */
    public function getDisputeToken()
    {
        return $this->container['dispute_token'];
    }

    /**
     * Sets dispute_token
     *
     * @param string|null $dispute_token Unique identifier of the dispute, if the ledger entry is disputed.
     *
     * @return self
     */
    public function setDisputeToken($dispute_token)
    {
        $this->container['dispute_token'] = $dispute_token;

        return $this;
    }

    /**
     * Gets group
     *
     * @return string
     */
    public function getGroup()
    {
        return $this->container['group'];
    }

    /**
     * Sets group
     *
     * @param string $group Group to which the ledger entry belongs.
     *
     * @return self
     */
    public function setGroup($group)
    {
        $allowedValues = $this->getGroupAllowableValues();
        if (!in_array($group, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'group', must be one of '%s'",
                    $group,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['group'] = $group;

        return $this;
    }

    /**
     * Gets id
     *
     * @return string
     */
    public function getId()
    {
        return $this->container['id'];
    }

    /**
     * Sets id
     *
     * @param string $id Eight-digit numeric identifier of the ledger entry, an alternate identifier to the UUID that is useful for remembering and referencing.
     *
     * @return self
     */
    public function setId($id)
    {
        if ((mb_strlen($id) > 8)) {
            throw new \InvalidArgumentException('invalid length for $id when calling LedgerEntry., must be smaller than or equal to 8.');
        }
        if ((mb_strlen($id) < 8)) {
            throw new \InvalidArgumentException('invalid length for $id when calling LedgerEntry., must be bigger than or equal to 8.');
        }

        $this->container['id'] = $id;

        return $this;
    }

    /**
     * Gets impact_time
     *
     * @return \DateTime
     */
    public function getImpactTime()
    {
        return $this->container['impact_time'];
    }

    /**
     * Sets impact_time
     *
     * @param \DateTime $impact_time Date and time when the ledger entry impacts the account balance.  For purchases, this is the time of the authorization.  For purchase authorization clearings, this is the time when the transaction is settled.
     *
     * @return self
     */
    public function setImpactTime($impact_time)
    {
        $this->container['impact_time'] = $impact_time;

        return $this;
    }

    /**
     * Gets memo
     *
     * @return string
     */
    public function getMemo()
    {
        return $this->container['memo'];
    }

    /**
     * Sets memo
     *
     * @param string $memo Merchant name or description for the ledger entry.
     *
     * @return self
     */
    public function setMemo($memo)
    {
        $this->container['memo'] = $memo;

        return $this;
    }

    /**
     * Gets original_currency
     *
     * @return \OpenAPI\Client\Model\OriginalCurrency|null
     */
    public function getOriginalCurrency()
    {
        return $this->container['original_currency'];
    }

    /**
     * Sets original_currency
     *
     * @param \OpenAPI\Client\Model\OriginalCurrency|null $original_currency original_currency
     *
     * @return self
     */
    public function setOriginalCurrency($original_currency)
    {
        $this->container['original_currency'] = $original_currency;

        return $this;
    }

    /**
     * Gets related_token
     *
     * @return string|null
     */
    public function getRelatedToken()
    {
        return $this->container['related_token'];
    }

    /**
     * Sets related_token
     *
     * @param string|null $related_token Unique identifier of the original ledger entry. If the current ledger entry is the original, this field is returned empty.
     *
     * @return self
     */
    public function setRelatedToken($related_token)
    {
        $this->container['related_token'] = $related_token;

        return $this;
    }

    /**
     * Gets request_time
     *
     * @return \DateTime
     */
    public function getRequestTime()
    {
        return $this->container['request_time'];
    }

    /**
     * Sets request_time
     *
     * @param \DateTime $request_time For purchases, the date and time of the authorization, which is when the user initiates the ledger entry.  For other ledger entry groups, equivalent to `impact_time`.
     *
     * @return self
     */
    public function setRequestTime($request_time)
    {
        $this->container['request_time'] = $request_time;

        return $this;
    }

    /**
     * Gets root_token
     *
     * @return string|null
     */
    public function getRootToken()
    {
        return $this->container['root_token'];
    }

    /**
     * Sets root_token
     *
     * @param string|null $root_token Unique identifier of the root ledger entry. If the current ledger entry is the root, this field is returned empty.
     *
     * @return self
     */
    public function setRootToken($root_token)
    {
        $this->container['root_token'] = $root_token;

        return $this;
    }

    /**
     * Gets status
     *
     * @return string
     */
    public function getStatus()
    {
        return $this->container['status'];
    }

    /**
     * Sets status
     *
     * @param string $status Status of the ledger entry when it was initially recorded and had an impact on the balance, either `PENDING` or `POSTED`. This field is immutable and may not represent the current status.  To view the current status of purchases, refunds, OCTs, and payments, see the `detail_object.state` field. These journal entries start in `PENDING` and can transition to `CLEARED`, `DECLINED`, or `ERROR`. This transition of status is only sent through webhook event notifications.  Ledger entries that are final transactions, such as clearings, start and remain in a `POSTED` state.  *NOTE*: `CLEARED`, `DECLINED`, and `ERROR` are special statuses that do not have an impact on the account balance, and are not recorded in the ledger. For these special statuses, `impact_time`, `request_time`, `created_time`, `token`, and `id` are returned blank.
     *
     * @return self
     */
    public function setStatus($status)
    {
        $allowedValues = $this->getStatusAllowableValues();
        if (!in_array($status, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'status', must be one of '%s'",
                    $status,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['status'] = $status;

        return $this;
    }

    /**
     * Gets token
     *
     * @return string
     */
    public function getToken()
    {
        return $this->container['token'];
    }

    /**
     * Sets token
     *
     * @param string $token Unique identifier of the ledger entry.
     *
     * @return self
     */
    public function setToken($token)
    {
        $this->container['token'] = $token;

        return $this;
    }

    /**
     * Gets type
     *
     * @return string
     */
    public function getType()
    {
        return $this->container['type'];
    }

    /**
     * Sets type
     *
     * @param string $type Ledger entry event type.
     *
     * @return self
     */
    public function setType($type)
    {
        $this->container['type'] = $type;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed|null
     */
    public function offsetGet($offset)
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int|null $offset Offset
     * @param mixed    $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    public function jsonSerialize()
    {
       return ObjectSerializer::sanitizeForSerialization($this);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue()
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


